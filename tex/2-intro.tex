\Introduction

\section{Постановка проблемы}

\section{Цель и задачи}
Цель данной работы состоит в решении ряда задач, направленных на автоматизацию одного из видов тестирования ``белого'' ящика, а именно -- функционального тестирования приложений, созданных на базе игрового  движка \textit{Unity}, а именно: 
\begin{itemize}
	\item 
	создание расширяемой базы кода, которая бы отвечала всем требованиям принципов SOLID \cite{solid}, DRY \cite{dry} и принципа бритвы Оккама \cite{razor},
	\item
	компоновка решения в множество ассетов для легкой переносимости результирующего продукта, 
	\item а также  обеспечение интеграции в код уже написанных продуктов.
\end{itemize}  Результат данной работы представляет из себя набор дополнительных окон и утилит для редактора \textit{Unity} для записи и проигрывания сценариев, представляющих из себя записанные входные данные со всех периферийных устройств.

\subsection{Дополнительные задачи}
Дополнительное требование при реализации данного проекта -- возможность сериализовывать, экспортировать и импортировать записанные данные для последующего использования в построении сценария для тренажеров в виртуальной реальности \cite{disser}. Такая форма записи действий пользователя в виртуальной среде может быть использована для генерации сценария обучающего тренажера \cite{vr-simulators}, что поможет избежать рутинной работы по формированию треков обучения \cite{visual-editor}.

\subsection{Связанные работы}
Задача автоматизации функционального тестирования сегодня является довольно тривиальной, так как во многих популярных платформах, таких как Web, iOS, Android, она уже решена. Уже существуют разные инструменты для приложений с различными возможностями и характеристиками, такие как Selenium, Appium, Robotium и UI Automator. Формы решения данной задачи существуют разные, например, для Web используется WebDriver для записи и имитации ввода \cite{selenium}, для iOS и Android используется система RPC вызовов \cite{rpc_testing}, если же нет возможности вмешаться в поток вывода для облегчения записи, то используется компьютерное зрение для распознования как и с чем взаимодействует пользователь \cite{appium_opencv}. 

У каждой из формы есть свои плюсы и минусы, однако их всех объединяет одна модель поведения: запись действий пользователя и их проигрывание таким образом, чтобы субъект тестирования не различал реальный ли ввод или же записанный. Особняком здесь стоит вопрос об автоматизации тестирования приложений на игровом движке \textit{Unity}. Каждая из вышеупомянутых форм решения задачи в этом случае проигрывает в эффективности и степенью удобства интеграции, так как зачастую игры насыщены графикой и, в общем случае, не все игры вообще имеют графический интерфейс. В этой связи предлагается новая форма решения задачи, основанная на внутренней логике игрового движка \textit{Unity}, а именно на возможности декорирования методов взятия ввода, обусловленной внутренней архитектурой системы ввода.

\section{Объект и предмет разработки}
\subsection{Модель уровня определения требований}
\subsection{Модель уровня анализа требований}
\subsection{Модель уровня реализации требований}