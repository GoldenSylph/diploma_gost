\Conclusion
Согласно цели и задачам поставленным в начале данной выпускной квалификационной работе, были получены результаты, которые позволяют не только разрешить указанную проблему формального исполнителя для регрессионного тестирования, но и, в дополнение, применить эффективную \cite{open_source} модель дальнейшего развития проекта в качестве open-source ПО.

В процессе исследования популярности выбранного способа запрашивания ввода на платформе \textit{Unity} были созданы несколько версий spider-программ, однако предпочтения были отданы одной, которая в своём ядре разделяет процесс сбора данных с помощью параллельных вычислений. Также, в качестве приёма доказательства поставленной гипотезы была адаптирована под логическую функцию тождественности цепочка статистических выводов, что позволило успешно завершить исследование и приступить к проектированию.

Краткий анализ класса совместимых приложений позволил выделить основные приёмы разработки, которые были использованы для аналогов с других платформ. Были определены конкретные шаблоны проектирования и стратегические направления в развитии архитектуры группы ассетов, имеющие фундаментальные основания в объектно-ориентированном программировании.

Реализация системы управления зависимостями и автоматический инициализации перехватчика ввода позволила очистить исходный код основных систем от сквозного кода, благодаря использованию приёмов программной рефлексии (обращению к единицам компиляции как к классам и объектам) и возможностям языка программирования CSharp создавать атрибуты классов (аннотативные сущности, несущие вспомогательную информацию).

Главным выводом по факту создания основных систем группы ассетов, является то, что в большинстве своём исходный код подчиняется основным принципам проектирования SOLID, характерным для enterprise-проектов в объектно-ориентированном программировании. Это позволяет производить масштабирование функционала системы, используя всего два действия: создание .cs файла и аннотирование специальными атрибутами декларацию и зависимости класса добавляемой системы. Дальше, при переходе Unity Editor в Play Mode разработанная группа ассетов сама настроит новый функционал.

Благодаря выбранной архитектуре и построении зависимостей над абстрактными сущностями (интерфейсами, абстрактными классами и т.д.), все записи действий могут быть экспортированы и импортированы согласно двум основным системам: системе упаковки и системе сохранения и загрузки хранилища действий. Каждая из этих систем использует сигнатуры методов интерфейсов, поэтому создание и модификация этих систем не приведёт к лавинному эффекту с правками кода.

Реализация пользовательских окон управления данной группой ассетов для Unity Editor позволила быстро взаимодействовать с перехватом и записью действий без создания дополнительной кодовой базы, как если бы результаты данной работы были представлены лишь в виде Application Programmable Interface (API).

Говоря о полноте решений поставленных задач, конечно нельзя не заметить, что хоть и класс Input является самым распространённым среди других способов взятия ввода, огромная часть приложений использует и другие способы, а также их комбинации, в зависимости от целевой платформы сборки. Из этого следует, что дальнейший вектор развития данной работы указывает на охват большего количества способов взятия ввода. 

В дополнение нужно добавить что, развитие платформы \textit{Unity} тоже не стоит на месте, способ Input System, описанный в начале второй главы активно развивается и постепенно станет доминировать при переходе с объектно-ориентированного подхода к построению Unity-приложений к ориентированному на данные. Данный прогноз исходит из того, что если сейчас построить Unity-приложение с помощью уже существующих ориентированных на данные приёмов, то использование других способов запрашивания ввода станет технически невозможным.

Результат данной работы рекомендуется использовать в проектах с длинным временем прохождения и с линейным или частично линейным потоком действий. Также, благодаря активному развитию, следует осторожно использовать данную группу ассетов, так как ни один разработчик не застрахован от совершения алгоритмических ошибок.

Стоит отметить, что результаты данной работы были опубликованы в официальном магазине платформы \textit{Unity} Asset Store \cite{assetstore}. Также был сделан доклад на конференции Software Engineering Conference Russia (SECR 2019) \cite{secr} в городе Санкт-Петербург, с последующей подачей заявки на публикацию в журнал ``Программная инженерия'' \cite{prog_engine_journal}.

Исходный код размещён в личном репозитории автора ``https://github.com/GoldenSylph/Unity3DAutoTestFramework'', где будут отображаться возможные будущие изменения и форки, а копия на момент окончания написания данной работы размещена в репозитории Высшей школы ИТИС КФУ \cite{gitlab} и может быть рассмотрена для экспериментов.