\Conclusion
Согласно цели и задачам поставленным в начале данной выпускной квалификационной работы были получены результаты, которые позволяют не только разрешить указанную проблему формального исполнителя для регрессионного тестирования, но и в дополнение применить эффективную \cite{open_source} модель дальнейшего развития проекта в качестве open-source ПО.

В процессе исследования популярности выбранного способа запрашивания ввода на платформе \textit{Unity} были созданы несколько версий spider-программ, однако предпочтения были отданы одной, которая в своём ядре разделяет процесс сбора данных с помощью параллельных вычислений. Также, в качестве приёма доказательства поставленной гипотезы была адаптирована под логическую функцию тождественности цепочка статистических выводов, что позволило успешно завершить исследование и приступить к проектированию.

Краткий анализ класса совместимых приложений позволил выделить основные приёмы разработки, которые были использованы для аналогов с других платформ. Были определены конкретные шаблоны проектирования и стратегические направления в развитии архитектуры группы ассетов имеющие фундаментальные основания в объектно-ориентированном программировании.

Реализация системы управления зависимостями и автоматический инициализации перехватчика ввода позволило очистить исходный код основных систем от сквозного кода благодаря использованию приёмов программной рефлексии (обращению к единицам компиляции как к классам и объектам) и возможностям языка программирования CSharp создавать атрибуты классов (аннотативные сущности несущие вспомогательную информацию).

Главным выводом по факту создания основных систем группы ассетов, является то, что в большинстве своём исходный код подчиняется основным принципам проектирования SOLID характерным для enterprise-проектов в объектно-ориентированном программировании. Это позволяет производить масштабирование функционала системы используя всего два действия: создание .cs файла и аннотирование специальными атрибутами декларацию и зависимости класса добавляемой системы. Дальше, при переходе Unity Editor в Play Mode разработанная группа ассетов сама настроит новый функционал.

Благодаря выбранной архитектуре и построении зависимостей над абстрактными сущностями (интерфейсами, абстрактными классами и т.д.), все записи действий могут быть экспортированы и импортированы согласно двум основным системам: системе упаковки и системе сохранения и загрузки хранилища действий. Каждая из этих систем использует сигнатуры методов интерфейсов, поэтому создание и модификация этих систем не приведёт к лавинному эффекту с правками кода.

Реализация пользовательских окон управления данной группой ассетов для Unity Editor позволило быстро взаимодействовать с перехватом и записью действий без создания дополнительной кодовой базы, как если бы результаты данной работы были лишь представлены в виде Application Programmable Interface (API).

Говоря о полноте решений поставленных задач, конечно нельзя не заметить, что хоть и класс Input является самым распространённым среди других способов запрашивания ввода, огромная часть приложений использует и другие способы, а также их комбинации, в зависимости от целевой платформы сборки. Из этого следует, что дальнейший вектор развития данной работы указывает на охват большего количества способов запрашивания ввода. 

В дополнение, развитие платформы \textit{Unity} тоже не стоит на месте, способ Input System описанный в начале второй главы активно развивается и постепенно станет доминировать при переходе с объектно-ориентированного подхода к построению Unity-приложений к ориентированному на данные. Данный прогноз исходит из того, что если сейчас построить Unity-приложение с помощью уже существующих ориентированных на данные приёмов, то использование других способов запрашивания ввода станет технически невозможным.

Результат данной работы рекомендуется использовать в проектах с длинным временем прохождения и с линейным или частично линейным потоком действий. Также, благодаря активному развитию, следует осторожно использовать данную группу ассетов, так как ни один разработчик не застрахован от совершения алгоритмических ошибок.